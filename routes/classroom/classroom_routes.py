from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form, Body
from sqlalchemy.orm import Session
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from datetime import datetime
from services.classroom_id_generator import generate_classroom_id
from db import get_db
from models.classroom.classroom_models import Classroom
from models.auth.teacher_models import Teacher
from models.auth.student_models import Student
from models.courses.course_models import Course
from pathlib import Path
import shutil
import os

router = APIRouter(
    prefix="/api/classrooms",
    tags=["Classrooms"]
)


# Request schema for creating a classroom
# - `teacher_id`: ID of main teacher creating the class
# - `course_id`: ID of the course this classroom belongs to
# - `class_name`: optional human-friendly class name
# - `admins`: optional list of additional teacher IDs with admin rights
# - `description`: optional classroom description
class ClassroomCreate(BaseModel):
    teacher_id: str
    course_id: str
    class_name: Optional[str] = None
    admins: Optional[List[str]] = None
    description: Optional[str] = None


# Request schema to add a student to a classroom
# - `admin_id`: ID of the teacher/admin performing the action (authorization)
# - `student_id`: ID of the student to add
class AddStudentRequest(BaseModel):
    admin_id: str
    student_id: str


# Request schema for pushing daily content/link
# - `youtube_link`: URL to the video/content
# - `content_heading`: short heading/title for the day
# - `description`: optional longer description/notes
# - `date`: ISO8601 date string (defaults to now if omitted)
class PushLinkRequest(BaseModel):
    youtube_link: str
    content_heading: Optional[str] = None
    description: Optional[str] = None
    date: Optional[str] = None  # ISO string, default now


# Response schema for classroom data returned by APIs
# includes metadata, members, admins, photo path, and daily content items
class ClassroomOut(BaseModel):
    classroom_id: str
    class_name: Optional[str]
    teacher_id: str
    course_id: str
    admins: Optional[List[str]] = None
    description: Optional[str] = None
    classroom_photo: Optional[str] = None
    students: Optional[List[str]] = None
    daily_links: Optional[List[Dict[str, Any]]] = None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# Classroom IDs are generated by `services.classroom_id_generator.generate_classroom_id`

# Helper to save uploaded classroom photos to `/uploads/classrooms/{classroom_id}/`
# returns a path relative to project `BASE_DIR`


# Uploads base dir
BASE_DIR = Path(__file__).resolve().parent.parent.parent
CLASSROOM_UPLOADS = BASE_DIR / "uploads" / "classrooms"
CLASSROOM_UPLOADS.mkdir(parents=True, exist_ok=True)


def _save_classroom_photo(upload_file: UploadFile, classroom_id: str) -> str:
    class_dir = CLASSROOM_UPLOADS / classroom_id
    class_dir.mkdir(parents=True, exist_ok=True)
    ext = Path(upload_file.filename).suffix or ""
    filename = f"photo{ext}"
    file_path = class_dir / filename
    with file_path.open("wb") as buffer:
        shutil.copyfileobj(upload_file.file, buffer)
    # return path relative to BASE_DIR
    return os.path.relpath(file_path, BASE_DIR)


@router.post("/create", response_model=ClassroomOut, status_code=status.HTTP_201_CREATED)
# Create a new classroom
# Parameters:
# - body `payload` (JSON): uses `ClassroomCreate` fields
# - optional multipart file `classroom_photo`: image to store under uploads
def create_classroom(payload: ClassroomCreate, classroom_photo: Optional[UploadFile] = File(None), db: Session = Depends(get_db)):
    # validate teacher
    teacher = db.query(Teacher).filter_by(teacher_id=payload.teacher_id).first()
    if not teacher:
        raise HTTPException(status_code=404, detail="Teacher not found")

    # validate course
    course = db.query(Course).filter_by(course_id=payload.course_id).first()
    if not course:
        raise HTTPException(status_code=404, detail="Course not found")

    # validate provided admins (if any)
    admins_list = payload.admins or []
    for t_id in admins_list:
        if not db.query(Teacher).filter_by(teacher_id=t_id).first():
            raise HTTPException(status_code=404, detail=f"Admin teacher not found: {t_id}")

    classroom_id = generate_classroom_id(now)
    now = datetime.utcnow()
    photo_path = None
    if classroom_photo:
        photo_path = _save_classroom_photo(classroom_photo, classroom_id)

    classroom = Classroom(
        classroom_id=classroom_id,
        class_name=payload.class_name,
        teacher_id=payload.teacher_id,
        course_id=payload.course_id,
        students=[],
        daily_links=[],
        admins=admins_list or [],
        description=payload.description,
        classroom_photo=photo_path,
        created_at=now,
        updated_at=now,
    )
    db.add(classroom)
    db.commit()
    db.refresh(classroom)
    return classroom


@router.get("/get-all", response_model=List[ClassroomOut])
# List all classrooms
def get_all_classrooms(db: Session = Depends(get_db)):
    return db.query(Classroom).all()


@router.get("/get-by/{classroom_id}", response_model=ClassroomOut)
# Get classroom by `classroom_id`
def get_classroom(classroom_id: str, db: Session = Depends(get_db)):
    classroom = db.query(Classroom).filter_by(classroom_id=classroom_id).first()
    if not classroom:
        raise HTTPException(status_code=404, detail="Classroom not found")
    return classroom


@router.get("/get-by-teacher/{teacher_id}", response_model=List[ClassroomOut])
# Get all classrooms owned/created by a teacher (teacher_id)
def get_by_teacher(teacher_id: str, db: Session = Depends(get_db)):
    return db.query(Classroom).filter_by(teacher_id=teacher_id).all()


@router.put("/put/{classroom_id}/add-student", response_model=ClassroomOut)
# Add student to classroom
# Path param: `classroom_id`
# Body JSON: `admin_id` (requester) and `student_id` (to add)
def add_student_to_class(classroom_id: str, payload: AddStudentRequest, db: Session = Depends(get_db)):
    classroom = db.query(Classroom).filter_by(classroom_id=classroom_id).first()
    if not classroom:
        raise HTTPException(status_code=404, detail="Classroom not found")

    # authorize admin
    if payload.admin_id != classroom.teacher_id and payload.admin_id not in (classroom.admins or []):
        raise HTTPException(status_code=403, detail="Not authorized to add students")

    student = db.query(Student).filter_by(student_id=payload.student_id).first()
    if not student:
        raise HTTPException(status_code=404, detail="Student not found")

    students = classroom.students or []
    if payload.student_id in students:
        raise HTTPException(status_code=400, detail="Student already in classroom")

    students.append(payload.student_id)
    classroom.students = students
    classroom.updated_at = datetime.utcnow()
    db.add(classroom)
    db.commit()
    db.refresh(classroom)
    return classroom


class AdminChangeRequest(BaseModel):
    # Request schema to add/remove an admin
    # - `admin_id`: ID of requester admin/owner
    # - `teacher_id`: teacher ID to grant admin rights
    admin_id: str
    teacher_id: str


@router.put("/put/{classroom_id}/add-admin", response_model=ClassroomOut)
# Grant admin rights to a teacher for a classroom
# Path param: `classroom_id`
# Body JSON: `admin_id` (requester) and `teacher_id` (to add as admin)
def add_admin_to_class(classroom_id: str, payload: AdminChangeRequest, db: Session = Depends(get_db)):
    classroom = db.query(Classroom).filter_by(classroom_id=classroom_id).first()
    if not classroom:
        raise HTTPException(status_code=404, detail="Classroom not found")

    # authorize requester
    if payload.admin_id != classroom.teacher_id and payload.admin_id not in (classroom.admins or []):
        raise HTTPException(status_code=403, detail="Not authorized to add admins")

    teacher = db.query(Teacher).filter_by(teacher_id=payload.teacher_id).first()
    if not teacher:
        raise HTTPException(status_code=404, detail="Teacher not found")

    admins = classroom.admins or []
    if payload.teacher_id in admins:
        raise HTTPException(status_code=400, detail="Teacher already an admin for this classroom")

    admins.append(payload.teacher_id)
    classroom.admins = admins
    classroom.updated_at = datetime.utcnow()
    db.add(classroom)
    db.commit()
    db.refresh(classroom)
    return classroom


class RemoveMemberRequest(BaseModel):
    # Request schema to remove a student
    # - `admin_id`: ID of requester admin/owner
    # - `student_id`: ID of the student to remove
    admin_id: str
    student_id: str


@router.put("/put/{classroom_id}/remove-student", response_model=ClassroomOut)
# Remove a student from a classroom
# Path param: `classroom_id`
# Body JSON: `admin_id` (requester) and `student_id` (to remove)
def remove_student_from_class(classroom_id: str, payload: RemoveMemberRequest, db: Session = Depends(get_db)):
    classroom = db.query(Classroom).filter_by(classroom_id=classroom_id).first()
    if not classroom:
        raise HTTPException(status_code=404, detail="Classroom not found")

    if payload.admin_id != classroom.teacher_id and payload.admin_id not in (classroom.admins or []):
        raise HTTPException(status_code=403, detail="Not authorized to remove students")

    students = classroom.students or []
    if payload.student_id not in students:
        raise HTTPException(status_code=404, detail="Student not a member of classroom")

    students.remove(payload.student_id)
    classroom.students = students
    classroom.updated_at = datetime.utcnow()
    db.add(classroom)
    db.commit()
    db.refresh(classroom)
    return classroom


@router.post("/put/{classroom_id}/push-link", response_model=ClassroomOut)
# Push a daily content item (heading, description, link)
# Path param: `classroom_id`
# Body JSON: `youtube_link`, optional `content_heading`, `description`, and `date`
def push_daily_link(classroom_id: str, payload: PushLinkRequest, db: Session = Depends(get_db)):
    classroom = db.query(Classroom).filter_by(classroom_id=classroom_id).first()
    if not classroom:
        raise HTTPException(status_code=404, detail="Classroom not found")

    links = classroom.daily_links or []
    entry_date = payload.date or datetime.utcnow().isoformat()
    links.append({
        "date": entry_date,
        "heading": payload.content_heading,
        "description": payload.description,
        "link": payload.youtube_link,
    })
    classroom.daily_links = links
    classroom.updated_at = datetime.utcnow()
    db.add(classroom)
    db.commit()
    db.refresh(classroom)
    return classroom


@router.put("/put/{classroom_id}/update", response_model=ClassroomOut)
# Update classroom metadata (name, description, photo)
# Path param: `classroom_id`
# Form fields: `admin_id` (requester), optional `class_name`, optional `description`, optional `classroom_photo` (file)
def update_classroom(classroom_id: str,
                     admin_id: str = Form(...),
                     class_name: Optional[str] = Form(None),
                     description: Optional[str] = Form(None),
                     classroom_photo: Optional[UploadFile] = File(None),
                     db: Session = Depends(get_db)):
    classroom = db.query(Classroom).filter_by(classroom_id=classroom_id).first()
    if not classroom:
        raise HTTPException(status_code=404, detail="Classroom not found")

    # authorize
    if admin_id != classroom.teacher_id and admin_id not in (classroom.admins or []):
        raise HTTPException(status_code=403, detail="Not authorized to update classroom")

    if class_name is not None:
        classroom.class_name = class_name
    if description is not None:
        classroom.description = description
    if classroom_photo:
        photo_path = _save_classroom_photo(classroom_photo, classroom_id)
        classroom.classroom_photo = photo_path

    classroom.updated_at = datetime.utcnow()
    db.add(classroom)
    db.commit()
    db.refresh(classroom)
    return classroom


@router.delete("/delete-by/{classroom_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_classroom(classroom_id: str, db: Session = Depends(get_db)):
    classroom = db.query(Classroom).filter_by(classroom_id=classroom_id).first()
    if not classroom:
        raise HTTPException(status_code=404, detail="Classroom not found")
    db.delete(classroom)
    db.commit()
    return None


@router.delete("/bulk/delete", status_code=status.HTTP_204_NO_CONTENT)
def bulk_delete(request: Dict[str, Any] = Body(...), db: Session = Depends(get_db)):
    ids = request.get("classroom_ids") or []
    if not isinstance(ids, list):
        raise HTTPException(status_code=400, detail="classroom_ids must be a list")
    db.query(Classroom).filter(Classroom.classroom_id.in_(ids)).delete(synchronize_session=False)
    db.commit()
    return None
